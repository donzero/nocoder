<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[slf4j日志框架学习]]></title>
    <url>%2F2018%2F05%2F29%2Flog_slf4j%2F</url>
    <content type="text"><![CDATA[slf4j(Simple Logging Facade for Java) 即简单日志门面，不是具体的日志解决方案，它只服务于各种各样的日志系统，如java.util.logging, logback和log4j。 概念SLF4J 提供了统一的记录日志的接口，对不同日志系统的具体实现进行了抽象化，只要按照其提供的方法记录即可，最终日志的格式、记录级别、输出方式等通过绑定具体的日志系统来实现。 使用SLF4J的好处在于，你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。 slf4j 重要的接口与类 Logger：接口，用来记录日志，提供了打印各种级别日志的功能； ILoggerFactory：接口，获取 Logger； LoggerFactory：类，获取 Logger 的门面，他的内部是通过ILoggerFactory 来获取 Logger 的； 注意建议使用 slf4j 而不是 log4j。参考http://www.importnew.com/7450.html slf4j-api 包是日志的接口，log4j, logback 等等才是日志的真正实现。slf4j-simple 包是 slf4j 提供的一个简单实现 。 日志规范在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用slf4j： 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 参考slf4j 官网 SLF4J简介与使用(整合log4j) Slf4j分析]]></content>
      <categories>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>slf4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz 组件学习]]></title>
    <url>%2F2018%2F05%2F29%2Fquartz%2F</url>
    <content type="text"><![CDATA[Quartz 是 OpenSymphony 开源组织在 任务调度 领域的一个开源项目，完全基于 Java 实现。 获取资源可以在官网 http://www.quartz-scheduler.org/ 学习或下载 Quartz 发布版本及其源代码。 Maven 管理的项目可以在 pom.xml 中引入依赖( version 请参照官网与实际选择)：12345678910&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * 自定义的任务,实现Job接口 * @author deng * @date 2018年5月29日 */public class MyJob implements Job&#123; private static Logger logger = LoggerFactory.getLogger(MyJob.class); @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobDetail jobDetail = context.getJobDetail(); //String description = jobDetail.getDescription(); logger.info("这是quartz的job实现:\n" + jobDetail.toString()); &#125;&#125;/** * 任务监听，实现JobListener接口 * * @author deng * @date 2018年5月29日 */public class MyJobListener implements JobListener &#123; public static final String LISTENER_NAME = "myJobListenerName"; @Override public String getName() &#123; return LISTENER_NAME; &#125; /** * Scheduler 在 JobDetail 将要被执行时调用这个方法 */ @Override public void jobToBeExecuted(JobExecutionContext context) &#123; String jobName = context.getJobDetail().getKey().toString(); System.out.println("Job : " + jobName + " 将被执行..."); &#125; /** * Scheduler 在 JobDetail 即将被执行，但又被 TriggerListener 否决了时调用这个方法 */ @Override public void jobExecutionVetoed(JobExecutionContext context) &#123; String jobName = context.getJobDetail().getKey().toString(); System.out.println("Job : " + jobName + " 被否决。 "); &#125; /** * Scheduler 在 JobDetail 被执行之后调用这个方法 */ @Override public void jobWasExecuted(JobExecutionContext context, JobExecutionException jobException) &#123; String jobName = context.getJobDetail().getKey().toString(); System.out.println("Job : " + jobName + " 执行完毕..."); /*if (!jobException.getMessage().equals("")) &#123;// 版本问题出现异常 System.out.println("Job: " + jobName + " 发生异常: " + jobException.getMessage()); &#125;*/ &#125;&#125;/** * quartz 学习 * * @author deng * @date 2018年5月29日 */public class QuartzStu &#123; private static Logger logger = LoggerFactory.getLogger(QuartzStu.class); public static void main(String[] args) &#123; myJobStu(); &#125; public static void myJobStu() &#123; try &#123; // 创建scheduler Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 创建Scheduler的工厂 //SchedulerFactory sf = new StdSchedulerFactory(); // 从工厂中获取调度器实例 //Scheduler scheduler = sf.getScheduler(); // 创建Trigger ,使用SimpleScheduleBuilder或者CronScheduleBuilder Trigger trigger = TriggerBuilder.newTrigger() .withDescription("个人任务的触发器") .withIdentity("myTrigger", "myTriggerGroup") .startAt(new Date()) // 默认当前时间启动 // .withSchedule(SimpleScheduleBuilder.simpleSchedule()) .withSchedule(CronScheduleBuilder.cronSchedule("0/10 * * * * ?")) // 10秒执行一次 .build(); // 定义一个JobDetail JobDetail jobDetail = JobBuilder.newJob(MyJob.class) .withDescription("个人任务") .withIdentity("myJob", "myJobGroup") .build(); // 新建监听器 MyJobListener listener = new MyJobListener(); // 构造匹配pickNewsJob中的JobKey的keyMatcher（单个任务的监听器） Matcher&lt;JobKey&gt; matcher = KeyMatcher.keyEquals(jobDetail.getKey()); // 任务组的监听器 // Matcher&lt;JobKey&gt; groupMatcher = GroupMatcher.jobGroupContains("myTriggerGroup"); // 为job添加全局监听器 scheduler.getListenerManager().addJobListener(listener, matcher); // 加入这个调度 scheduler.scheduleJob(jobDetail, trigger); // 启动 scheduler.start(); logger.info("任务调度启动"); // 运行一段时间后关闭 Thread.sleep(10000); // 关闭 scheduler.shutdown(true); logger.info("任务调度停止"); &#125; catch (SchedulerException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参考Quartz 教程 Quartz 学习 JobListener 分版本超详细解析]]></content>
      <categories>
        <category>调度框架</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
        <tag>调度框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring Ioc]]></title>
    <url>%2F2018%2F05%2F24%2Fspring_ioc%2F</url>
    <content type="text"><![CDATA[概念控制反转是一个对象如何获取它所依赖的对象的引用； 控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。 参考Spring：源码解读Spring IOC原理]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 系统基础]]></title>
    <url>%2F2018%2F05%2F21%2Flinux_base%2F</url>
    <content type="text"><![CDATA[在写这篇文章前，我在思考，为什么要学linux。相对于windows的简单粗暴无脑的操作系统，linux系统确实需要更多的学习才能驾驭它。 为什么学linux，无非开源的（社区发达，它的任何问题都能找到解决方案），免费的（嗯。你不需要支付版权等费用，部分基于linux系统的可能要），高可用的（良好的运行状态，基本不会出现卡顿问题）…等。知乎上有一篇关于《为什么学习linux的文章》的讨论，ZHANG Zaikun 的回答可能会让你我满意。 简介Linux 内核最初只是由芬兰人李纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。Linux 是一套免费使用和自由传播的类Unix操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 的发行版Linux的发行版说简单点就是将Linux内核与应用软件做一个打包。目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。 Linux 应用领域各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或LNMP（Linux + Nginx+ MySQL + PHP）组合。 Linux vs Windows目前国内Linux更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。请参考（看看就行）：windows和linux到底有哪些区别？ 系统安装各发行版本安装自己 baidu 或 google。脚本安装还不会，暂且搁置。 系统启动过程Linux系统的启动过程可以分为5个阶段： 内核的引导； 运行 init； 系统初始化； 建立终端； 用户登录系统； 可以参考 Linux 的启动流程 内核引导当计算机打开电源后，首先是 BIOS 开机自检，按照 BIOS 中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。 运行initinit 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 /etc/inittab。 init程序的类型： SysV: init, CentOS 5之前, 配置文件： /etc/inittab; Upstart: init, CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf； Systemd： systemd, CentOS 7,配置文件: /usr/lib/systemd/system、 /etc/systemd/system; 运行级别许多程序需要开机启动。它们在 Windows 叫做”服务”（service），在 Linux 就叫做”守护进程”（daemon）。init 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。 Linux系统有7个运行级别(runlevel)： 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有 NFS) 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11 控制台，登陆后进入图形 GUI 模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 系统初始化在 init 的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit 它调用执行了/etc/rc.d/rc.sysinit，而 rc.sysinit 是一个 bash shel l的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。 建立终端rc(系统初始化)执行完毕后，返回 init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init 接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端： 1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6 用户登录系统一般来说，用户的登录方式有三种: 命令行登录; SSH 登录; 图形界面登录; 图形模式与文字模式的切换方式Linux 预设提供了六个命令窗口终端机让我们来登录。默认我们登录的就是第一个窗口，也就是 tty1，你可以按下 Ctrl + Alt + F1 ~ F6 来切换它们。如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按 Ctrl + Alt + F1 ~ F6 来进入其中一个命令窗口界面。当你进入命令窗口界面后再返回图形界面只要按下 Ctrl + Alt + F7 就回来了。 Linux 关机正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt关机指令为：shutdown ，你可以 man shutdown 来看一下帮助文档。12345678910111213141516171819sync 将数据由内存同步到硬盘中。shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。Shutdown –h now 立马关机Shutdown –h 20:25 系统会在今天20:25关机Shutdown –h +10 十分钟后关机Shutdown –r now 系统立马重启Shutdown –r +10 系统十分钟后重启reboot 就是重启，等同于 shutdown –r nowhalt 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6 Linux 系统目录结构以下是对这些目录的解释： /bin：bin 是 Binary 的缩写, 这个目录存放着最经常使用的命令； /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件； /dev ：dev 是 Device (设备)的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux中访问设备的方式和访问文件的方式是相同的； /etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。sysfs文件系统集成了下面3种文件系统的信息： 针对进程信息的 proc 文件系统; 针对设备的 devfs 文件系统 针对伪终端的 devpts 文件系统。 /tmp：这个目录是用来存放一些临时文件的。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的program files 目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。 Linux 忘记密码解决方法参考：Linux 忘记密码解决方法 参考Linux 教程 -runoob]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux收集学习]]></title>
    <url>%2F2018%2F05%2F21%2Flinux_collect%2F</url>
    <content type="text"><![CDATA[设置全局目录变量进入 shell 中，每次输入 cd /usr/java/jdk1.6.0_43 或更多级目录让人头疼，可以设置全局变量，每次进入可以如下使用：12345[jboss6@receipt ~]$[jboss6@receipt ~]$ cd $JAVA_HOME[jboss6@receipt jdk1.6.0_43]$ pwd/usr/java/jdk1.6.0_43[jboss6@receipt jdk1.6.0_43]$ 编辑 profile 文件 用 vi 或 vim 编辑 /etc/profile 文件（root 用户才有可写权限, 也可以 chmod u+w /etc/profile 给用户添加可写权限）: vim /etc/profile ； 按键盘 i 进入编辑模式，在文件末尾 unset i 前添加 export JAVA_HOME=/usr/java/jdk1.6.0_43，按键盘 Esc，输入 :wq! 保存文件； Source 让设置立即生效 想让配置立刻生效，而不用重新登录用 source 命令：source /etc/profile 你可以使用 cd $JAVA_HOME 快速进入 jdk 目录了，其他脚本中也可以使用该变量； sudo sudo -l 查看sudo权限 sudo -u username /bin/mkdir logs 新建 logs 文件夹]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[srpingBoot 学习]]></title>
    <url>%2F2018%2F05%2F15%2Fspring_boot%2F</url>
    <content type="text"><![CDATA[Spring Boot 是由Pivotal团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。其约定优于配置的惯例，让开发者写更少的配置，程序能够更快的运行和启动。 概念Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa 等等。但他们的基础都是 Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC 是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种 XML、 JavaConfig、hin 处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了 spring 的配置流程。 Spring 是一个”引擎”、”核心”； Spring MVC 是基于 Spring 的一个 MVC 框架； Spring Boot 是基于 Spring4 的一套快速开发整合包； 快速构建 新建maven项目，配置pom.xml: 1234567891011121314151617181920212223242526&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.12.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;finalName&gt;spring-boot-stu&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;!--fork : 如果没有该项配置，devtools不会起作用，即应用不会restart --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 新建配置java类： 12345678910111213141516/** * 新建类（类名不重要），配置@SpringBootApplication注解 * @author deng * @date 2018年5月15日 */@SpringBootApplicationpublic class Application &#123; /** * 应用启动入口 * @param args */ public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 运行上述java类的main方法，即默认(约定)配置启动，浏览器访问：http://localhost:8080/项目名 即可（因为没有编写接口，默认页面是这样-丑）。 在 resources 目录配置配置文件，新建 application.yml（或 application.properties），默认为空。可以写点配置 ,程序的端口为8180，context-path为 /boot-demo 123server: port: 8180 context-path: /boot-demo 新建demoController： 1234567891011121314/** * demo 'hello' * @RestController 将低版本spring的@controller与@ResponseBody 合并 * @author deng * @date 2018年5月15日 */@RestControllerpublic class DemoController &#123; @RequestMapping("/hello") public String hello()&#123; return "hello,springBoot"; &#125;&#125; 再次运行上述配置java类的main方法，浏览器访问：http://localhost:8180/boot-demo/hello 即可。你可以看到页面显示：hello,springBoot。 属性配置可以用配置文件新增属性配置内容：1234567server: port: 8180 context-path: /boot-demopeople: name: nocoder work: IT 可以用以下两种读取属性配置文件： 使用 @Value 读取单个属性 1234567891011121314@Componentpublic class PropertiesStu &#123; @Value("$&#123;people.name&#125;") private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 使用 @ConfigurationProperties(prefix = &quot;people&quot;) 读取某一节点所有属性： 123456789101112131415161718192021222324@ConfigurationProperties(prefix = "people")@Componentpublic class PropertiesStu &#123; private String name; private String work; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getWork() &#123; return work; &#125; public void setWork(String work) &#123; this.work = work; &#125;&#125; 其他类调用： 12345678910// @RequestMapping("/people/&#123;id&#125;")@RequestMapping(value = "/people/&#123;id&#125;", method = &#123; RequestMethod.POST, RequestMethod.GET &#125;)public String people(@PathVariable("id") String id) &#123; StringBuffer sb = new StringBuffer(); sb.append("id=" + id + "\t"); sb.append("name=" + propertiesStu.getName() + "\t"); //sb.append("work=" + propertiesStu.getWork() + "\t"); return sb.toString();&#125; 参考SpringBoot非官方教程 CSDN]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA 加密算法]]></title>
    <url>%2F2018%2F05%2F15%2Fsecurity_RSA%2F</url>
    <content type="text"><![CDATA[RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。 对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式解破。 背景与原理RSA 公开密钥密码体制。所谓的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。 Java 应用RSA 公钥密钥的创建 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class RsaStu&#123; /** * 生成RSA公钥私钥Demo */ public static void rsaStu()&#123; /** RSA算法要求有一个可信任的随机数源 */ SecureRandom random = new SecureRandom(); KeyPairGenerator keyPairGenerator = null; try &#123; keyPairGenerator = KeyPairGenerator.getInstance("RSA");//RSA/ECB/PKCS1PADDING &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return;//或者 throw new Exception(); &#125; keyPairGenerator.initialize(512, random);//秘钥长度 ,最短512 KeyPair keyPair = keyPairGenerator.generateKeyPair(); /* 生成公钥 */ RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); /* 生成私钥 */ RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); System.out.println("RSA publicKey:" + parseByte2HexStr(publicKey.getEncoded())); System.out.println("RSA privateKey:" + parseByte2HexStr(privateKey.getEncoded())); &#125; /** * * 功能描述: 将二进制转换成16进制字符串 * @param buf 二进制组 * @return 十六进制字符串 * @date: 2018年3月8日 */ private static String parseByte2HexStr(byte buf [])&#123; StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; buf.length; i++)&#123; String hex = Integer.toHexString(buf[i] &amp; 0xFF); if(hex.length() == 1)&#123; hex = '0' + hex; &#125; sb.append(hex.toUpperCase()); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Security</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常电脑技巧收集]]></title>
    <url>%2F2018%2F05%2F15%2Fcollected_sum%2F</url>
    <content type="text"><![CDATA[主要记录日常电脑收集的小技巧。 DNS问题windows 系统正确配置了 IP/DNS、代理等信息，网络仍不可用，除了禁用网络连接（本地网络或无线网络），还可以使用 cmd 刷新重置DNS服务器： 12345678910C:\Windows\system32&gt;ipconfig/flushdnsWindows IP 配置已成功刷新 DNS 解析缓存。C:\Windows\system32&gt;ipconfig/registerdnsWindows IP 配置已经初始化了注册此计算机的所有适配器的 DNS 资源记录。任何错误都将在 15 分钟内在事件查看器中报告。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>电脑</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AES 加密算法]]></title>
    <url>%2F2018%2F05%2F15%2Fsecurity_AES%2F</url>
    <content type="text"><![CDATA[AES 加密算法是密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael 加密法(严格地说，AES 和 Rijndael 加密法并不完全一样，AES 算是Rijndael 算法的一种特殊实现)，是美国联邦政府采用的一种区块加密标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 算法原理AES 的基本要求是，采用对称分组密码体制，密钥的长度最少支持为128、192、256，分组长度必须为128位（16字节，排列：4x4 竖着排的矩阵），算法应易于各种硬件和软件实现。 AES 算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。AES 使用几种不同的方法来执行排列和置换运算。 Java 应用AES 密钥的创建以下为三种密钥生成方式Demo.可根据实际情况选用或拓展： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * * @author deng */class AesStu &#123; /** * 根据原始密钥创建AES密钥 * @param key */ public static void aesStu(String key)&#123; try &#123; // 创建一个 DESKeySpec 对象，使用 key中的前 8个字节，这里采用base64加密后的数组，作为 DES 密钥的密钥内容 DESKeySpec dks = new DESKeySpec(new Base64().decode(key)); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey sk = keyFactory.generateSecret(dks); // 将密钥的基本编码格式(二进制)转化成16进制的字符串 System.out.println(byteToHexString(sk.getEncoded())); &#125; catch (Exception e) &#123;//直接省略其他Exception，代码规范... e.printStackTrace(); &#125; &#125; /** * 随机生成秘钥 */ public static void getKey() &#123; try &#123; // KeyGenerator 提供（对称）密钥生成器的功能，可重复使用 KeyGenerator kg = KeyGenerator.getInstance("AES"); // 要生成多少位，只需要修改这里即可128, 192或256 kg.init(128); SecretKey sk = kg.generateKey(); System.out.println(byteToHexString(sk.getEncoded())); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125; /** * 使用指定的字符串生成秘钥 * @param pwd */ public static void getKeyByPass(String pwd) &#123; // 生成秘钥 try &#123; KeyGenerator kg = KeyGenerator.getInstance("AES"); // SecureRandom是生成安全随机数序列，password.getBytes()是种子，只要种子相同，序列就一样，所以生成的秘钥就一样。 kg.init(128, new SecureRandom(pwd.getBytes())); SecretKey sk = kg.generateKey(); System.out.println(byteToHexString(sk.getEncoded())); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125; /** * byte数组转化为16进制字符串 * @param bytes * @return */ private static String byteToHexString(byte[] bytes) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; bytes.length; i++) &#123; String strHex = Integer.toHexString(bytes[i]); if (strHex.length() &gt; 3) &#123; sb.append(strHex.substring(6)); &#125; else &#123; if (strHex.length() &lt; 2) &#123; sb.append("0" + strHex); &#125; else &#123; sb.append(strHex); &#125; &#125; &#125; return sb.toString(); &#125;&#125; 参考AES加密算法 百度百科 AES(Rijndael算法) CSDN AES自动生成base64密钥加密解密 CSDN]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Security</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自由的含义]]></title>
    <url>%2F2018%2F05%2F14%2Fcollected_free%2F</url>
    <content type="text"><![CDATA[学会用自己的脑袋思考，按自己的意志行事，并为自己的行为负责。这时自由的本意… 自由即责任，世人多畏之。 若无力驾驭，自由便是负担。 毕马隆效应：他人的期望会在一定程度上影响我们的行为。]]></content>
      <categories>
        <category>mind</category>
      </categories>
      <tags>
        <tag>mind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之网络编程]]></title>
    <url>%2F2018%2F05%2F13%2Fjava_net%2F</url>
    <content type="text"><![CDATA[网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。Java 语言可编写低层的网络应用。例如，传输文件，建立邮件控制器，处理网络数据等。Java 语言支持的 Internet 协议有 ftp、telnet、www 等，支持网络通信的软件都在 java.net 包中，例如，java.net.ftp、java.net.www等。 TCP/IP，HTTP,FTP等协议名词解释请参考网络基础教程或网上搜索 基础知识TCP/IPTCP/IP分为四个层次： 网络接口层：负责接收和发送物理帧； 网络层：负责相邻节点之间的通信； 传输层：负责起点到终点的通信； 应用层：提供诸如文件传输、电子邮件等应用程序。 TCP/IP 协议是一个协议族，由一组协议组成，主要包含以下更具体的协议： Telnet（远程登录）：允许一台计算机用户登录到另一台远程计算机上，使远程操作如同在本地计算机上操作一样； FTP（File Transfer protocol，文件传输协议）：允许用户将远程主机上的文件复制到自己的计算机上； SMTP（simple Mail Transfer Protocol，简单邮件传输协议）：用于传输电子邮件； NFS（Network file Server，网络文件服务器）：使多台计算机透明地访问彼此的目录； HTTP：一种超文本传输协议，它是基于 TCP/IP 协议的，是 WWW 浏览器和服务器之间应用层的通信协议。HTTP 是一种通用、无状态、面向对象的协议。HTTP 会话（事务）包括四个步骤：连接（Connection）、请求（Request）、应答（Response）和关闭（Close）； IP 地址用于指明因特网上的一台计算机在网络中的地址，用32 位二进制代码表示一个网络地址。地址分A、B、C、D、E五类，常用的是A、B、C三类： A（1.0.0.0-126.255.255.255）：0,7位网络号，后24位为主机号； B（128.0.0.0-191.255.255.255）：10,14位网络号,后16位为主机号； C（192.0.0.0-223.255.255.255）：110,21位网络号,后8位为主机号； D（224.0.0.0-239.255.255.255）：1110,28位多点广播组标号； E（240.0.0.0-254.255.255.255）：1111,保留试验使用。 java.net 包中提供了两种常见的网络协议的支持： TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。 URL统一资源定位符 URL(Uniform Resource Locator) 是 www 客户机访问 Internet 时用来标识资源的名字和地址。超文本链路由统一资源定位符 URL 维持。格式是： &lt;METHOD&gt;://&lt;HOSTNAME:PORT&gt;/&lt;PATH&gt;/&lt;FILE&gt; Method 是传输协议; HOSTNAME 是文档和服务器所在的 Internet 主机名（域名系统中 DNS 中的点地址）; PORT 是服务端口号（可省略）; PATH 是路径名; FILE 是文件名。 InetAddressJava.net 包中有 InetAddress 类的定义，InetAddress 类的对象用于 IP 地址和域名，该类提供以下方法： getByName(String s)：获得一个 InetAddress 类的对象，该对象中含有主机的 IP 地址和域名，该对象用如下格式表示它包含的信息：www.sina.com.cn/202.108.37.40； getHostName()：获取 InetAddress 对象的域名； getHostAddress()：获取 InetAddress 对象的 IP 地址； getLocalHost()：获得一个 InetAddress 对象，该对象含有本地机的域名和 IP 地址； 123456789try &#123; // 以下代码通过域名建立InetAddress对象： InetAddress addr = InetAddress.getByName("www.baidu.com"); String domainName = addr.getHostName();// 获得主机名 String IPName = addr.getHostAddress();// 获得IP地址 System.out.println(domainName); System.out.println(IPName); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; URL 与 URLConnectionURLJava.net 包有 URL 类，一个 URL 对象可以表示一个网络资源。程序利用 URL 对象能实现Internet 寻址、网络资源的定位连接、在客户机与服务器之间直接访问等。 URLConnection要接收和发关信息还要用 URLConnection 类，程序获得一个 URLConnection 对象，相当于完成对指定URL的一个HTTP连接。URLConnection类提供的以下方法: getOutputStream()：获得向远程主机发送信息的 OutputStream 流对象； getInputStream()：获得从远程主机获取信息的 InputStream 流对象。有了网络连接的输入和输出流，程序就可实现远程通信； connect()：设置网络连接 123456789101112131415try &#123; String urlName = "https://www.baidu.com"; URL url = new URL(urlName);// 由网址创建URL对象 URLConnection tc = url.openConnection();// 获得URLConnection对象 tc.connect();// 设置网络连接 InputStreamReader in = new InputStreamReader(tc.getInputStream()); BufferedReader dis = new BufferedReader(in);// 采用缓冲式输入 String inline; while ((inline = dis.readLine()) != null) &#123; System.out.println(inline + "\n"); &#125; dis.close();// 网上资源使用结束后，数据流及时关闭&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Socket 套接字Java 语言在实现 C/S 模式中，套接字分为两类： Server端，ServerSocket 类支持底层的网络通信； Client端，Socket 类支持网络的底层通信; 双方实现通信有流式socket和数据报式socket两种可选方式： 流式 socket 是有连接的通信，即 TCP(Transmission Control Protocol)：每次通信前建立连接，通信结束后断开连接。特点是可以保证传输的正确性、可靠性。 数据报式 socke t是无连接的通信，即 UDP(User Datagram Protocol)：将欲传输的数据分成 小包，直接上网发送。无需建立连接和拆除连接，速度快，但无可靠保证。当 Client 程序和 Server 程序需要通信时，可以用 Socket 类建立套接字连接。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 ServerSocket服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。常用方法： getLocalPort()：返回此套接字在其上侦听的端口； accept()：侦听并接受到此套接字的连接； setSoTimeout(int timeout)：通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位； bind(SocketAddress host, int backlog)：将 ServerSocket 绑定到特定地址（IP 地址和端口号）； Socketjava.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。 注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法： connect(SocketAddress host, int timeout)：将此套接字连接到服务器，并指定一个超时值； getInetAddress()：返回套接字连接的地址； getPort()：返回此套接字连接到的远程端口； getLocalPort()：返回此套接字绑定到的本地端口。 getRemoteSocketAddress()：返回此套接字连接的端点的地址，如果未连接则返回 null； getInputStream()：返回此套接字的输入流； getOutputStream()：返回此套接字的输出流； close()：关闭此套接字； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class SocketStu&#123; /** * 服务段练习 */ public void server() &#123; ServerSocket server = null; Socket you = null; String s = null; DataOutputStream out = null; DataInputStream in = null; try &#123; server = new ServerSocket(4441); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; you = server.accept(); in = new DataInputStream(you.getInputStream()); out = new DataOutputStream(you.getOutputStream()); while (true) &#123; s = in.readUTF(); System.out.println(s); if (s.equals("#"))&#123; break; &#125; &#125; out.writeUTF("hello, this is server!"); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 客户端练习 */ public void client() &#123; String s = null; Socket mySocket; DataInputStream in = null; DataOutputStream out = null; try &#123; mySocket = new Socket("localhost", 4441); in = new DataInputStream(mySocket.getInputStream()); out = new DataOutputStream(mySocket.getOutputStream()); out.writeUTF("hello server,I'm client!"); while (true) &#123; s = in.readUTF(); if (s == null)&#123; break; &#125; else &#123; System.out.println(s); &#125; &#125; mySocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参考Java 网络编程(runoob)Java网络与数据库编程基础]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之输入输出]]></title>
    <url>%2F2018%2F05%2F12%2Fjava_io%2F</url>
    <content type="text"><![CDATA[输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，如从键盘上读取数据，从本地或网络上的文件读取数据或写入数据等。通过输入和输出操作可以从外界接收信息，或者是把信息传递给外界。 流的概念流（Stream）是指在计算机的输入输出操作中各部件之间的数据流动。Java 中一个流被定义为一个数据序列。 流的分类 输入流与输出流流按照数据的传输方向，可分为输入流与输出流（针对内存输入或输出）。一般来说关于流的特性有下面几点： 先进先出，最先写入输出流的数据最先被输入流读取到； 顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据； 只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流； 字节流与字符流流按照数据的传输单位，可分为字节流与字符流。 字节流：读写8位二进制的字节； 字符流：读写16位二进制的字符； 节点流与过滤流（待争琢）流按照功能，可分为节点流与过滤流。 节点流：直接操作目标设备的流，eg：磁盘或内存； 过滤流：对一个已存在的流的封装，对数据进行处理，为程序提供功能强大、灵活的读写功能，不直接操作数据源；eg:缓冲流：为了提高数据的传输效率，引入了缓冲流（Buffered Stream）的概念，即为一个流配备一个缓冲区（Buffer），一个缓冲区就是专门用于传送数据的一块内存。 字节流字节流以字节为传输单位，用来读写8位的数据，除了能够处理纯文本文件之外，还能用来处理二进制文件的数据。由于 InputStream 和 OutputStream 都是抽象类，是所有字节流的父类。所以在程序中创建的输入流对象一般是它们某个子类的对象，通过调用对象继承的 read() 和 write() 方法就可实现对相应外设的输入输出操作。 InputStream面向字节的输入流都是 InputStream 类的子类，其类层次结构如图: InputStream 流类中包含一套所有输入都需要的方法，可以完成最基本的从输入流读入数据的功能，常用方法： read()：从输入流中当前位置读入一个字节的二进制数据，以此数据为低位字节，补足16位的整型量（0~255）后返回，若输入流中当前位置没有数据，则返回-1； read(byte b[])：从输入流中的当前位置连续读入多个字节保存在数组中，并返回所读取的字节数； int read(byte b[], int off, int len)：从输入流中当前位置连续读 len 长的字节，从数组第off+1个元素位置处开始存放，并返回所读取的字节数； available()：返回输入流中可以读取的字节数； skip(long n)：跳过流内的n个字符； close()：关闭输入流； FileInputStreamFileInputStream 是用于从文件读取字节数据的 InputStream 子类。 123456789101112131415161718FileInputStream fis = null;try &#123; fis = new FileInputStream("G:/hexoWorkspace/ioStu.txt"); int date = -1; while ((date = fis.read()) != -1) &#123; System.out.println((char)date); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; if(null != fis)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; OutputStream面向字节的输出流都是 OutputStream 类的子类，其类层次结构如图： OutputStream 流类中包含一套所有输出都需要的方法，可以完成最基本的向输出流写入数据的功能，常用方法： write(int b)：将参数b的低位字节写入到输出流； write(byte b[])：按顺序将数组b[]中的全部字节写入到输出流； write(byte b[], int off, int len)：按顺序将数组b[]中第off+1个元素开始的len个数据写入到输出流； flush()：强制清空缓冲区并执行向外设输出数据； close()：关闭输出流； FileOutputStreamFileOutputStream 是用于向文件写入字节数据的 OutputStream 子类。 1234567891011121314151617FileOutputStream fos = null;try &#123; fos = new FileOutputStream("G:/hexoWorkspace/ioStu.txt"); String str = "hello,FileOutputStream 练习"; str.getBytes(); fos.write(str.getBytes());&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; if(null != fos)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符流字符流是针对字符数据的特点进行过优化的，因而提供一些面向字符的有用特性，字符流的源或目标通常是文本文件。由于 Reader 和 Writer 都是抽象类，是 java.io 包中所有字符流的父类，所以应使用它们的子类来创建实体对象，利用对象来处理相关的读写操作。Reader 和 Writer 的子类又可以分为两大类：一类用来从数据源读入数据或往目的地写出数据（称为节点流），另一类对数据执行某种处理（称为处理流）。 Reader面向字符的输入流类都是 Reader 的子类，其类层次结构如图： 可以利用 Reader 所提供的这些方法来获得流内的位数据，常用方法： read()：从输入流中读取一个字符； read(char[] ch)：从输入流中读取字符数组； read(char[] ch, int off, int len)：从输入流中读 len 长的字符到 ch 内； ready()：测试流是否可以读取； reset()：重定位输入流； skip(long n)：跳过流内的 n 个字符； close()：关闭输入流； FileReaderFileReader 类是 Reader 子类 InputStreamReader 类的子类，因此 FileReader 类既可以使用Reader 类的方法也可以使用 InputStreamReader 类的方法来创建对象。 需要注意的是，Java 把一个汉字或英文字母作为一个字符对待，回车或换行作为两个字符对待。 1234567891011char a[] = new char[100]; // 创建可容纳 100 个字符的数组 try &#123; FileReader fb = new FileReader("G:/hexoWorkspace/ioStu.txt"); int num = fb.read(a); // 将数据读入到数组 a 中，并返回字符数 String str = new String(a, 0, num); // 将字符串数组转换成字符串 System.out.println("读取的字符个数为：" + num + ",内容为：\n"); System.out.println(str); fb.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; BufferedReaderBufferedReader 类是用来读取缓冲区中的数据。使用时必须创建 FileReader 类对象，再以该对象为参数创建 BufferedReader 类的对象。 1234567891011String readline;try &#123; FileReader a = new FileReader("G:/hexoWorkspace/ioStu.txt"); BufferedReader b = new BufferedReader(a); while ((readline = b.readLine()) != null) &#123; // 每次读取 1 行 System.out.println(readline); &#125; b.close();&#125; catch (IOException io) &#123; e.printStackTrace();&#125; Writer面向字符的输出流都是类 Writer 的子类，其类层次结构如图： Writer 的常用方法： close()：关闭输出流； flush()：将缓冲区中的数据写到文件中； writer(int c)：将单一字符 c 输出到流中； writer(String str)：将字符串 str 输出到流中； writer(char[] ch)：将字符数组 ch 输出到流； writer(char[] ch, int offset, int length)：将一个数组内自 offset 起到 length 长的字符输出到流； FileWriterFileWriter 类是 Writer 子类 OutputStreamWriter 类的子类，因此 FileWriter 类既可以使用 Writer类的方法也可以使用 OutputStreamWriter 类的方法来创建对象。 12345678try &#123; FileWriter fw = new FileWriter("G:/hexoWorkspace/ioStu.txt"); String str = "hello,fileWriter."; fw.write(str); fw.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; BufferedWriterBufferedWriter 类是用来将数据写入到缓冲区。使用时必须创建 FileWriter 类对象，再以该对象为参数创建。 12345678910try&#123; BufferedWriter bw = new BufferedWriter(new FileWriter("G:/hexoWorkspace/ioStu.txt")); String str = "hello,bufferedWriter."; bw.write(str); bw.flush(); bw.close();&#125;catch(IOException e)&#123; e.printStackTrace();&#125; RandomAccessFileJava.io 包提供了 RandomAccessFile 类用于随机文件的创建和访问。使用这个类，可以跳转到文件的任意位置读写数据。程序可以在随机文件中插入数据，而不会破坏该文件的其他数据。此外，程序也可以更新或删除先前存储的数据，而不用重写整个文件。 是JAVA I/O流体系中功能最丰富的文件内容访问类，它提供了众多方法来访问文件内容； 由于可以自由访问文件的任意位置，所以如果需要访问文件的部分内容，RandomAccessFile将是更好的选择； 可以用来访问保存数据记录的文件，文件的记录的大小不必相同，但是其大小和位置必须是可知的； 123456789101112131415161718192021222324BufferedReader br = null;RandomAccessFile raf = null;try &#123; br = new BufferedReader(new InputStreamReader(System.in)); String s = br.readLine(); raf = new RandomAccessFile("G:/hexoWorkspace/ioStu.txt", "rws");// 第二个参数为模式，包括(只读:"r",读写:"rw",读写加内容更新同步写入底层存储设备:"rws","rwd"?) // 移动到文件结尾 raf.seek(raf.length()); // 写入数据，任意访问文件的指针在文件的结尾 raf.writeBytes(s + "\n"); // 读取时，将指针重置到文件的开始位置 raf.seek(0); // 跳过8字节 // raf.skipBytes(8) ; // TODO:有问题 System.out.println(raf.readLine()); br.close(); raf.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 标准输入输出System.in、System.out、System.err 这 3 个标准输入输流对象定义在 java.lang.System 包中，这 3 个对象在 Java 源程序编译时会被自动加载。 标准输入：标准输入 System.in 是 BufferedInputStream 类的对象，当程序需要从键盘上读入数据时，只需要调用 System.in 的 read()方法即可，该方法从键盘缓冲区读入一个字节的二进制数据，返回以此字节为低位字节，高位字节为 0 的整型数据。 标准输出：标准输出 System.out 是打印输出流 PrintStream 类的对象。PrintStream 类是过滤输出流类 FilterOutputStream 的一个子类，其中定义了向屏幕输出不同类型数据的方法print()和 println()。 标准错误输出：System.err 用于为用户显示错误信息，也是由 PrintStream 类派生出来的错误流。Err 流的作用是使 print()和 println()将信息输出到 err 流并显示在屏幕上，以方便用户使用和调试程序。 流的应用场景 FileInputStream/FileOutputStream：需要逐个字节处理原始二进制流的时候使用，效率低下 FileReader/FileWriter：需要组个字符处理的时候使用 StringReader/StringWriter：需要处理字符串的时候，可以将字符串保存为字符数组 PrintStream/PrintWriter：用来包装F ileOutputStream 对象，方便直接将String字符串写入文件 Scanner：用来包装System.in流，很方便地将输入的 String 字符串转换成需要的数据类型 InputStreamReader/OutputStreamReader：字节和字符的转换桥梁，在网络通信或者处理键盘输入的时候用 BufferedReader/BufferedWriter：BufferedInputStream/BufferedOutputStream ， 缓冲流用来包装字节流后者字符流，提升 IO 性能，BufferedReader 还可以方便地读取一行，简化编程。 File文件类请参考API，eg: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * File练习 * @author deng */class FileStu &#123; private int fileLevels = 0; /** * 遍历File * @param file */ public void iteratorDir(File file)&#123; if(null!=file)&#123; // 文件或空目录返回 if(file.isFile() || file.listFiles().length == 0)&#123; return; &#125;else&#123; File[] files = sort(file.listFiles()); for(File f:files)&#123; StringBuilder sb = new StringBuilder(); if(f.isFile())&#123; sb.append(getTab(fileLevels)); sb.append(f.getName()); &#125;else&#123; sb.append(getTab(fileLevels)); sb.append(f.getName()); sb.append("/"); &#125; System.out.println(sb.toString()); if(f.isDirectory())&#123; fileLevels ++;//进入目录 iteratorDir(f);//递归遍历文件夹 fileLevels --;//退出目录 &#125; &#125; &#125; &#125; &#125; /** * 对File列表排序，先文件夹后文件 * @param files * @return */ private File[] sort(File[] files)&#123; List&lt;File&gt; fileList = new ArrayList&lt;File&gt;(); /* 先目录，再文件 */ for(File file:files)&#123; if(file.isDirectory())&#123; fileList.add(file); &#125; &#125; for(File file:files)&#123; if(file.isFile())&#123; fileList.add(file); &#125; &#125; // list 转换数组 return fileList.toArray(new File[fileList.size()]); &#125; /** * 根据文件目录级别返回制表符 * @param level 文件目录级别 * @return */ private String getTab(int level)&#123; StringBuilder sb = new StringBuilder(); for(int i = 0; i&lt;level;i++)&#123; sb.append("\t"); &#125; return sb.toString(); &#125;&#125; 参考Java 流(Stream)、文件(File)和IO(runoob) Java输入输出(IO)操作 Java IO完全总结 JAVA基础知识之IO]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之多线程]]></title>
    <url>%2F2018%2F05%2F12%2Fjava_thread%2F</url>
    <content type="text"><![CDATA[Java内置支持多线程编程（multithreaded programming）。对于多线程与多进程的区别建议参考《计算机编程原理》。 进程：正在进行中的程序，就是一个应用程序运行时的内存分配空间 线程：进程中一个程序的执行控制单元，一条执行路径。 进程负责的是应用程序的空间的标示，线程负责的是应用程序的执行顺序。CPU 随机性原理：因为 CPU 的快速切换造成，那个线程获取到了 CPU 的执行权，那个线程就执行。 线程的几种状态 被创建：start(); 运行：具备执行资格，同时具备执行权; 冻结：sleep（time）,wait()—–notify()唤醒，线程冻结（沉睡），释放了执行权，同时释放了执行资格; 临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权; 消亡：stop(); Java 中线程方法与状态 新建状态：线程对象创建(new)时，仅为对象，可设置属性，没有分配资源；setName() 设置线程名;setPriority() 设置优先级;setDaemon() 设置线程类型(用户/守护线程)； 就绪状态：线程对象执行 start()，系统分配除 CPU 外所有资源；yield()：放弃 CPU 资源，重新进入就绪状态； 运行状态：java 通过系统调度，使其占有 CPU 资源，系统真正被执行；isAlive()：判断线程(true)就绪/运行状态，(false)阻塞/停止状态； 阻塞状态：线程不能继续运行；sleep() 等阻塞方法时，线程置入阻塞集里面，等待超时或自动苏醒；多个线程进入同步区域，没能进入该区域的线程被置入锁定集，直到获得同步区域锁，进入就绪状态；wait() 时，线程置入等待集，直到该线程的 notify()。wait()/notify() 执行要求线程首先获得该对象的锁； 死亡状态：线程执行结束后进入死亡状态，此外interrupt()/stop()以异常方式退出进入死亡状态；线程执行完毕正常退出，如设定结束标识，while(flag)，设定flag=false；stop() 强制终止线程（已过时，不建议使用，可能引起不可预料的结果）；interrupt() 强制中断线程，不推荐使用； 线程的创建方式继承 Thread 定义类继承 Thread 类; 重写 run() 方法; 通过创建 Thread 类的子类对象，创建线程对象; 调用线程的 start 方法，开启线程，并执行 run 方法; 12345678910111213141516171819202122232425262728293031323334/** * 线程学习 * @author deng */public class ThreadStu&#123; public static void main(String[] args) &#123; MyThread myThread1 = new MyThread(); myThread1.start(); MyThread myThread2 = new MyThread(); myThread2.start(); MyThread myThread3 = new MyThread(); myThread3.start(); &#125;&#125;class MyThread extends Thread&#123; private static int i = 0; @Override public void run() &#123; while(i&lt;10)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(this.getName()+":"+i ++); &#125; &#125;&#125; 实现 Runable 定义类实现 Runnable 接口。 覆盖接口中的 run 方法。（用于封装线程要运行的代码）。 通过 Thread 类创建线程对象。 将实现了 Runnable 接口的子类作为实际参数传递给 Thread 类中的构造函数。（为什么要这么做？是为了让线程对象明确要运行的 run 方法所属的对象）。 调用 Thread 对象的 start 方法。开启线程，并运行 Runnable 接口子类中的 run 方法。 1234567891011121314151617181920212223242526272829303132333435/** * 线程学习 * @author deng */public class ThreadStu&#123; public static void main(String[] args) &#123; MyRunnable runnabel1 = new MyRunnable(); //可以设置线程名 new Thread(runnabel1,"runnabel1").start(); //new Thread(runnabel1).start(); MyRunnable runnabel2 = new MyRunnable(); new Thread(runnabel2).start(); MyRunnable runnabel3 = new MyRunnable(); new Thread(runnabel3).start(); &#125;&#125;class MyRunnable implements Runnable &#123; private static int i = 0; public void run() &#123; while(i&lt;10)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // Runnable需使用Thread.currentThread()获取当前线程来获取当前线程信息 System.out.println(Thread.currentThread().getName()+":"+i ++); &#125; &#125;&#125; Thread 类定义了多种方法可以被派生类重载。对于所有的方法，惟一的必须被重载的是 run() 方法。当然实现 Runnable 接口所需的同样的方法。很多 Java 程序员认为类仅在它们被加强或修改时应该被扩展。因此，如果你不重载 Thread 的其他方法时，最好只实现 Runnable 接口。 线程同步防止多个线程访问同一个资源，对资源破坏。线程同步是保证线程安全访问竞争的手段。 java 对象都有一个内置锁； 当程序运行 synchronized 同步方法时，自动获得代码当前实例有关的锁；当程序运行 synchronized 同步代码快时，自动获得锁定对象的锁； 一个对象只有一个锁； 1234567891011121314public void run() &#123; // 同步锁 synchronized (this) &#123; while(i&lt;10)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // Runnable需使用Thread.currentThread()获取当前线程来获取当前线程信息 System.out.println(Thread.currentThread().getName()+":"+i ++); &#125; &#125;&#125; 死锁当一个线程获取对象1的锁时又想获取对象2的锁，而另一个线程有对象2的锁，获取对象1的锁，这种互相等待对方释放锁的过程，导致死锁。 参考Java 多线程编程(runoob)多线程编程]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习]]></title>
    <url>%2F2018%2F05%2F12%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis与hibernate的区别： hibernate是全自动，而mybatis是半自动。hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。 hibernate数据库移植性远大于mybatis。hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（oracle、mysql等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。 hibernate拥有完整的日志系统，mybatis则欠缺一些。hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。 mybatis相比hibernate需要关心很多细节。hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。 sql直接优化上，mybatis要比hibernate方便很多。由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础重点]]></title>
    <url>%2F2018%2F05%2F12%2Fjava_base_sum%2F</url>
    <content type="text"><![CDATA[常见的 java 基础收集记录，好记性不如烂笔头。本文收录记录常见的Java基础知识。 String相关String，StringBuffer,StringBuilder 区别 String 为强不可变对象（每次操作返回创建的新对象，不改变原 String 对象）Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程； StringBuffer 是线程安全的； StringBuilder 是非线程安全； 运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String； String 类的常用方法String 类的常用方法：length(),concat(String),startsWith(),endsWith(),indexOf(),lastIndexOf(),substring(),repalce(),matches(),replaceAll(),split(); new String(“xyz”)创建了几个对象首先得了解String作为最基础的引用数据类型，Java 设计者为 String 提供了字符串常量池以提高其性能（基于不可变的）。 JVM读到”xyz”的时候，首先去字符串常量池检查是否存在，如果不存在创建 “xyz” 字符串对象; JVM读到关键字 new 的时候，JVM会在堆中为其创建一个String对象； 综上，如果字符串常量池存在 “xyz” 常量则创建了1个对象；如果不存在，则创建2个对象。 字符串找数字给你一组字符串如：7i8hy4jjnb2.让你编程输出里面的数字：7842。123456String str = "iu7i8hy4jnb2";Pattern p = Pattern.compile( "\\d" );/*"\[0-9]\"*/Matcher matcher = p.matcher(str);while ( matcher.find() ) &#123; System.out.print(matcher.group());&#125; interface 和 abstractabstract class 和interface 是支持抽象类定义的两种机制，都不能实例化。 interface 实现类及 abstrctclass 的继承类(非 abstrctclass)子类都必须要实现已经声明的抽象方法。 interface 修饰类，abstrctclass 能修饰类，能修饰方法； interface 需要实现，要用 implements，而abstract class 需要继承，要用 extends； 一个类可以实现多个 interface，但一个类只能继承一个 abstract class； 尽管 interface 实现类及 abstrct class 的子类都必须要实现相应的抽象方法，但实现的形式不同。interface 中的每一个方法都是抽象方法，都只是声明的(declaration,没有方法体)，实现类必须要实现。而 abstractclass 的子类可以有选择地实现； interface 是完全抽象的，声明 pulic 的方法，不能声明 private 及 protected 的方法，不能定义方法体，也不能声明实例变量。然而，interface 却可以声明常量变量；… overload 和 overrideoverride（重写） 方法名、参数、返回值相同； 存在于父类和子类之间； 子类方法不能缩小父类方法的访问权限； 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)； 方法被定义为final不能被重写； overload（重载） 方法名相同，参数类型、个数、顺序至少有一个不相同； 不能重载只有返回值不同的方法名。 方法的修饰符可以不相同 存在于父类和子类、同类中。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之集合]]></title>
    <url>%2F2018%2F05%2F12%2Fjava_collention%2F</url>
    <content type="text"><![CDATA[java.util包中就包含了一系列重要的集合类，而对于集合类，主要需要掌握的就是它的内部结构，以及遍历集合的迭代模式。Collection 是所有单一对象的集合类的根接口，没有提供直接的实现类；有三个子接口：List(有序可重复),set(无序不可重复),queue(队列)。 Map 是 Java.util 包中的另一个接口，它和 Collection 接口没有关系，是相互独立的，但是都属于集合类的一部分。Map 包含了 key-value（Entity） 对。Map 不能包含重复的 key，但是可以包含相同的 value。 Iterator 迭代器Iterator 是 Java 集合的顶层接口（不包括 map 系列的集合，Map 接口是 map 系列集合的顶层接口），用于遍历集合中元素的接口。 Iterator 和 Iterable 接口 Iterable(存在于 java.lang 包中),封装了 Iterator 接口。所以只要实现了只要实现了Iterable接口的类，就可以使用Iterator迭代器了; Iterator(存在于 java.util 包中),核心的方法 next(),hasnext(),remove() Iterator：只能正向遍历集合，适用于获取移除元素。ListIerator：继承Iterator，可以双向列表的遍历，同样支持元素的修改 1234567Iterator it = list.iterator();//通过迭代器遍历元素Iterator it = collection.iterator();while(it.hasNext()) &#123; // 得到下一个元素 Object obj = it.next();&#125; List 接口List 是有序，可以重复的集合。List 关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往 List 集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器。 List 接口的三个典型实现： ArrayList：底层数据结构是数组(允许所有元素，包括 null)，查询快，增删慢;线程不安全，效率高; LinkedList：底层数据结构是链表(允许所有元素，包括 null)，查询慢，增删快; 线程不安全，效率高（LinkedList 不但继承了 List 接口，还继承了 Deque（double-ended queue），所以既拥有List的特征（快速查询、迭代等），又有双端队列的特征（用作队列、栈等））;实现线程安全的一种解决方法：List list = Collections.synchronizedList(new LinkedList(...)); Vector：同 ArrayList，但它是线程安全的，几乎已经淘汰了这个集合(Vector同步了每个方法); Set 接口Set 是无序（LinkedHashSet、TreeSet是有序…），不可重复的集合。检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 Set 接口的三个典型实现： HashSet：底层采用 哈希表算法，不保证元素的添加顺序，查询效率高；不可重复；线程不安全; LinkedHashSet：底层采用 链表 和 哈希表的算法。既保证了元素的添加顺序，也保证了查询效率。但是整体性能要低于 HashSet；线程不安全; TreeSet：底层使用 红黑树算法，擅长于范围查询；不保证元素的添加顺序，但是会对集合中的元素进行排序；线程不安全; Queue 接口方便的实现队列和栈及其相关的数据结构，实现类之一PriorityQueue优先队列。TODO:未接触 Map 接口Map 接口不是 Collection 接口的继承。而是从自己的用于维护键-值关联的接口层次结构入手。按定义，该接口描述了从不重复的键到值的映射。 Map 接口的五个典型实现： HashMap：是最常用的 Map，数据结构是数组+单链表的组合；它根据键的 HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以 HashMap 最多只允许一条记录的键为 Null，允许多条记录的值为 Null，线程不安全；HashMap可以通过 Map m = Collections.synchronizedMap(hashMap)来达到同步的效果; Hashtable：与 HashMap 类似，是 HashMap 的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtale 在写入时会比较慢，它继承自 Dictionary 类，不同的是它不允许记录的键或者值为null，同时效率较低。 ConcurrentHashMap：线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 LinkedHashMap：保存了记录的插入顺序，在用 Iteraor 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，在遍历的时候会比 HashMap 慢，有 HashMap 的全部特性； TreeMap：实现 SortMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。不允许 key 值为空，线程不安全； Map 遍历 KeySet()：将 Map 中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 123456Iterator it = map.keySet().iterator(); //获取迭代器while(it.hasNext())&#123; Object key = it.next(); System.out.println(map.get(key));&#125; entrySet()：方法返回一个实现Map.Entry 接口的对象集合。如果底层 Map 在Map.Entry 接口的setValue() 方法外部被修改，此条目集就会变得无效，并导致迭代器行为未定义; 123456//将map集合中的映射关系取出，存入到set集合Iterator it = map.entrySet().iterator();while(it.hasNext())&#123; Entry e =(Entry) it.next(); System.out.println(e.getKey () + ":" + e.getValue());&#125; 推荐使用第二种方式，即entrySet()方法，效率较高。 其他hashCode() 与 equal()hashCode()方法和equal()方法的作用其实一样，但是重写的 equal() 里一般比较复杂，效率低;利用 hashCode() 进行对比，因为只要生成一个 hash 值进行比较就可以了，效率很高。但hashCode()并不是完全可靠，生成hash值得公式可能存在的问题。 所以一般比较用 hashCode() 方法，当 hashCode 一致时，再用 equal() 去再对比，如果再一致，则说明两个对象相等。 Comparable 与 ComparatorComparable &amp; Comparator 都是用来实现集合中元素的比较、排序的。只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Compara学习 * @author deng */public class ComparaStu &#123; public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person(1)); persons.add(new Person(5)); persons.add(new Person(2)); persons.add(new Person(4)); persons.add(new Person(3)); Collections.sort(persons); for (int i = 0; i &lt; persons.size(); i++) &#123; System.out.println(persons.get(i).getId()); &#125; &#125;&#125;/** * 实现Comparable,重写compareTo * @author deng * @param &lt;T&gt; */class Person implements Comparable&lt;Person&gt; &#123; private int id; public Person() &#123; super(); &#125; public Person(int id) &#123; super(); this.id = id; &#125; @Override public int compareTo(Person person) &#123; return this.getId() - person.getId(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Compara学习 * @author deng */public class ComparaStu &#123; public static void main(String[] args) &#123; List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;(); cars.add(new Car("B1")); cars.add(new Car("A3")); cars.add(new Car("C1")); cars.add(new Car("A1")); cars.add(new Car("B2")); //没有实现Comparable重写compareTo方法不能直接排序，报错 //Collections.sort(cars); Collections.sort(cars,new Comparator&lt;Car&gt;()&#123; @Override public int compare(Car o1, Car o2) &#123; return o1.getNum().compareTo(o2.getNum()); &#125; &#125;); for (int i = 0; i &lt; cars.size(); i++) &#123; System.out.println(cars.get(i).getNum()); &#125; &#125;&#125;final class Car &#123; private String num; public Car() &#123; super(); &#125; public Car(String num) &#123; super(); this.num = num; &#125; public String getNum() &#123; return num; &#125; public void setNum(String num) &#123; this.num = num; &#125;&#125; 集合与数组 数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用； 集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用； 参考Java 集合框架 (runoob)JAVA集合类汇总]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之异常]]></title>
    <url>%2F2018%2F05%2F12%2Fjava_throwable%2F</url>
    <content type="text"><![CDATA[异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。本文为 Java 异常的学习整理。Throwable为异常类的最终父类，有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Throwable中常用方法有： getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null； getMeage()：返回异常的消息信息； printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值； Error（错误）Error 是程序无法处理的错误，表示运行应用程序中较严重问题。 大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError 。 这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception（异常）Exception 是程序本身可以处理的异常。异常可分为运行时异常跟编译异常。 运行时异常：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等; 编译异常：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等; finally 不一定被执行，例如 catch 块中有退出系统的语句 System.exit(-1); finally就不会被执行 参考Java 异常处理 (runoob)深入理解java异常处理机制]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础学习]]></title>
    <url>%2F2018%2F05%2F12%2Fjava_base%2F</url>
    <content type="text"><![CDATA[Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。 JDK、JRE、JVM 区别JDK = JRE + JVM + 其它。 JDK(Java Development Kit) 是 Java 开发工具包，针对Java开发员。JDK 中包含 JRE，在 JDK 的安装目录下有一个名为 jre 的目录，里面有两个文件夹 bin 和 lib，在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 和起来就称为 jre。 JRE(Java Runtime Environment)是 Java 运行环境，针对 Java 程序的用户。JRE 中包含了 JVM，runtime class libraries 和 Java application launcher ，这些是运行Java程序的必要组件。 JVM(java virtual machine)是 Java 虚拟机，针对 Java 程序。jre包含lib类库，所有的 Java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行。class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 学习参考Java 教程(runoob) Java 入门教程]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse设置打开文件目录]]></title>
    <url>%2F2018%2F05%2F04%2Feclipse_%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在使用 eclispe 开发中打开选中文件，默认情况为：选中文件/文件夹/包名–右击–Properties–Location–复制路径–打开我的电脑–粘贴地址–回车。相比 myeclispe 中快捷按钮打开文件所在目录不方便了很多。下面介绍 eclipse 中设置 myeclispe 中那种效果： 找到eclipse工具栏中 External Tools: 新建拓展工具配置： 配置工具配置：Name：C:/WINDOWS/explorer.exeArguments：${container_loc} 勾选展示以及配置确认完成： 配置完成后，选中相应的文件或文件夹点击External Tools位置即可打开文件或文件夹所在目录。]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>快捷设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集励志]]></title>
    <url>%2F2018%2F04%2F26%2Fcollected_%E9%B8%A1%E6%B1%A4%2F</url>
    <content type="text"><![CDATA[有时，情绪低落，你需要’鸡汤’。它可以是鸡汤，也可以不是鸡汤。君子务本,本立而道生。 《论语 学而》 做一件事儿需注意根本要素。 岁月已往者不可复，未来者不可期，见在者不可失。 《省心录》 过去的就让它过去，往事随风；未来是多变的，不能期待；现在的是你拥有的，活在当下。 我荒废的今日，正是昨日殒身之人祈求的明日。 佚名 以前网上传的哈佛图书馆名言之一，后面进一步查询，发现是网上的鸡汤文，不知出处。以前大三的时候有感，或许当时的我很适合这句，过着忙碌却又荒废的日子，如浮动的青萍，找不到落脚点。每天都应珍惜。 抱歉，应该把后面的尾巴（打赏以及版本脚注）去掉，没时间去研究改造优化hexo的next主题了，你就当没看见，空闲了看见了再改改~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logback学习笔记]]></title>
    <url>%2F2018%2F04%2F19%2Flog_logback%2F</url>
    <content type="text"><![CDATA[logback 是一个开源的日志框架组件，与 log4j 出自同一个开发者(Ceki Gülcü)之手。logback 常被认为是用来替代 log4j 的，与 log4j 相比其拥有更多的特性，同时也带来很大性能提升。 模块概念模块组成Logback 主要由三个模块组成： logback-core，提供了 logback 的核心功能，是另外两个组件的基础。 logback-classic，实现了 slf4j 的 API，所以当想配合 Slf4j 使用时，需要将 logback-classic 加入 classpath。 logback-access，为集成 servlet 环境而准备的，可提供 HTTP-access 的日志接口，比如说 tomcat 或者 jettyjetty。 重要概念在 logback 里，最重要的三个类分别是： Logger，位于 logback-classic 模块中。日志记录器，把它关联到应用对应的context上后，主要用于存放日志对象，定义日志类型，级别。 Appender，位于 logback-core 模块中。指定日志输出的目的地，目的地可以是控制台，文件，或者数据库等 Layout，位于 logback-core 模块中。负责把事件转换成字符串，格式化日志信息的输出 配置基础配置方式logback 提供的配置方式有以下几种： 编程式配置 xml 格式 groovy 格式 配置优先级顺序 在 classpath 中寻找 logback.groovy 文件， 如果没找到，则在 classpath 寻找继续寻找 logback-test.xml 文件 如果没找到，继续寻找 logback.xml 文件 如果没找到, jdk6+ 会调用 ServiceLoader 查找 com.qos.logback.classic.spi.Configurator 接口的第一个实现类 如果仍然没找到，则使用默认配置（打印到控制台） 不使用配置情况下：12345678910111213private static final Logger logger = LoggerFactory.getLogger(LogbackMain.class);public static void main(String[] args) &#123; logger.trace("logback的trace"); logger.debug("logback的debug"); logger.info("logback的info"); logger.warn("logback的warn"); logger.error("logback的error"); //打印 Logback 内部状态 LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory(); StatusPrinter.print(lc); &#125; 输出结果:1234567814:43:48.275 [main] DEBUG cn.cq.nocoder.log.LogbackMain - logback的debug14:43:48.278 [main] INFO cn.cq.nocoder.log.LogbackMain - logback的info14:43:48.278 [main] WARN cn.cq.nocoder.log.LogbackMain - logback的warn14:43:48.278 [main] ERROR cn.cq.nocoder.log.LogbackMain - logback的error14:43:48,236 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]14:43:48,236 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]14:43:48,236 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.xml]14:43:48,240 |-INFO in ch.qos.logback.classic.BasicConfigurator@68a750a - Setting up default configuration. 配置详解根节点根节点也就是&lt;configuration&gt;，属性如下： scan：当此属性设置为 true 时，配置文件如果发生改变，将会被重新加载，默认值为 true。 scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当 scan 为 true 时，此属性生效。默认的时间间隔为1分钟。 debug：当此属性设置为 true 时，将打印出 logback 内部日志信息，实时查看 logback 运行状态。默认值为 false。 例如：123&lt;configuration scan="true" scanPeriod="20 second" debug="false"&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 主子节点根节点 &lt;configuration&gt; 的子节点大概如下： appender： 负责写日志的组件。 logger： 设置某一个包或者具体的某一个类的日志打印级别、以及指定 &lt;appender&gt;。 root：根 logger。 因配置逻辑关系先介绍 logger 与 root，后介绍 appender。 logger 子节点用来设置某一个包或者具体的某一个类的日志打印级别、以及指定 &lt;appender&gt;。&lt;logger&gt; 仅有一个 name 属性，一个可选的 level 和一个可选的 additivity 属性。 name：用来指定受此 logger 约束的某一个包或者具体的某一个类。 level：用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF（定义类：ch.qos.logback.classic.Level）。还有一个特殊值 INHERITED 或者同义词 NULL，代表强制执行上级的级别。如果未设置此属性，那么当前 logger 将会继承上级的级别。 additivity：是否向上级 logger 传递打印信息。默认是 true。 &lt;logger&gt; 可以包含零个或多个 &lt;appender-ref&gt; 元素，标识这个 appender 将会添加到这个 logger。 日志打印级别logger 有日志打印级别，可以为一个 logger 指定它的日志打印级别。如果不为一个 logger 指定打印级别，那么它将继承离他最近的一个有指定打印级别的祖先的打印级别。如果 logger 先找它的父亲，而它的父亲没有指定打印级别，那么它会立即忽略它的父亲，往上继续寻找它爷爷，直到它找到 root logger。因此，也能看出来，要使用 logback， 必须为 root logger 指定日志打印级别。日志打印级别从低级到高级排序的顺序是：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR。 获取 logger在 logback 中，每个 logger 都是一个单例，调用 LoggerFactory.getLogger 方法时，如果传入的 logger name 相同，获取到的 logger 都是同一个实例。在为 logger 命名时，用类的全限定类名作为 logger name 是最好的策略，这样能够追踪到每一条日志消息的来源。 root 子节点也是 &lt;logger&gt; 元素，但是它是根 logger。只有一个 level 属性，应为已经被命名为 ”root”. level：用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为 INHERITED 或者同义词 NULL。默认是 DEBUG。 &lt;root&gt; 可以包含零个或多个 &lt;appender-ref&gt; 元素，标识这个 appender 将会添加到这个 logger。12345678910111213&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="cn.cq.deng.logback"/&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/configuration&gt; 其中 appender 的配置表示打印到控制台 (稍后详细讲解 appender)。&lt;logger name=&quot;cn.cq.deng.logback&quot;/&gt; 将控制 logback 包下的所有类的日志的打印，但是并没有设置打印级别，所以继承他的上级 &lt;root&gt; 的日志级别 “DEBUG”。没有设置 additivity，默认为 true，将此 logger 的打印信息向上级传递。没有设置 appender，此 logger 本身不打印任何信息。&lt;root level=&quot;INFO&quot;&gt; 将 root 的打印级别设置为 “INFO” ，指定了名字为 “STDOUT” 的 appender。首先执行 &lt;logger name=&quot;cn.cq.deng.logback&quot;/&gt;，将级别为 “DEBUG” 及大于 “DEBUG” 的日志信息传递给 root，本身并不打印。root 接到下级传递的信息，交给已经配置好的名为 “STDOUT” 的 appender 处理， “STDOUT”appender 将信息打印到控制台。 appender 子节点&lt;appender&gt; 是 &lt;configuration&gt; 的子节点，是负责写日志的组件。&lt;appender&gt; 有两个必要属性name和class。name指定appender名称，class指定appender的全限定名。 ConsoleAppender把日志添加到控制台，有以下子节点： &lt;encoder&gt;：对日志进行格式化。（具体参数稍后讲解 ） &lt;target&gt;：字符串 System.out 或者 System.err ，默认 System.out. 例如：1234567891011&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/configuration&gt; FileAppender把日志添加到文件，有以下子节点: &lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 &lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 &lt;encoder&gt;：对记录事件进行格式化。详见下文 &lt;prudent&gt;：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。 例如：12345678910111213&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt; &lt;file&gt;testFile.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt; &lt;/configuration&gt; RollingFIleAppender滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子节点： &lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 &lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 &lt;encoder&gt;：对记录事件进行格式化。（具体参数稍后讲解 ） &lt;rollingPolicy&gt;:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 &lt;triggeringPolicy&gt;: 告知 RollingFileAppender 何时激活滚动。 &lt;prudent&gt;：当为true时，不支持 FixedWindowRollingPolicy。支持 TimeBasedRollingPolicy，但是有两个限制: 不支持也不允许文件压缩 不能设置file属性，必须留空 另外还有SocketAppender、SMTPAppender、DBAppender、SyslogAppender、SiftingAppender，并不常用，这些就不在这里讲解了，大家可以参考官方文档。当然大家可以编写自己的Appender。 rollingPolicyTimeBasedRollingPolicy最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责触发滚动。有以下子节点： &lt;fileNamePattern&gt;: 必要节点，包含文件名及“%d”转换符，%d”可以包含一个 Java.text.SimpleDateFormat 指定的时间格式，如：%d{yyyy-MM}。如果直接使用 %d，默认格式是 yyyy-MM-dd。RollingFileAppender 的file字节点可有可无，通过设置file，可以为活动文件和归档文件指定不同位置，当前日志总是记录到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据fileNamePattern 的值，每隔一段时间改变一次。“/”或者“\”会被当做目录分隔符。 &lt;maxHistory&gt;: 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且&lt;maxHistory&gt;是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 FixedWindowRollingPolicy根据固定窗口算法重命名文件的滚动策略。有以下子节点: &lt;minIndex&gt;:窗口索引最小值。 &lt;maxIndex&gt;:窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12。 &lt;fileNamePattern &gt;: 必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 没有log%i.log.zip triggeringPolicySizeBasedTriggeringPolicy查看当前活动文件的大小，如果超过指定大小会告知 RollingFileAppender 触发当前活动文件滚动。只有一个节点: &lt;maxFileSize&gt;:这是活动文件的大小，默认值是10MB。 例如：每天生产一个日志文件，保存30天的日志文件12345678910111213141516&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt; &lt;/configuration&gt; 又例如：按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志12345678910111213141516171819202122&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;test.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;fileNamePattern&gt;tests.%i.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt; &lt;/configuration&gt; encoder负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。目前 PatternLayoutEncoder 是唯一有用的且默认的 encoder ，有一个 &lt;pattern&gt; 节点，用来设置日志的输入格式。使用“%”加“转换符”方式，如果要输出“%”，则必须用“\”对“\%”进行转义。例如：123&lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; 格式修饰符，与转换符共同使用：可选的格式修饰符位于“%”和转换符之间。第一个可选修饰符是左对齐 标志，符号是减号“-”；接着是可选的最小宽度 修饰符，用十进制数表示。如果字符小于最小宽度，则左填充或右填充，默认是左填充（即右对齐），填充符为空格。如果字符大于最小宽度，字符永远不会被截断。最大宽度 修饰符，符号是点号”.”后面加十进制数。如果字符大于最大宽度，则从前面截断。点符号“.”后面加减号“-”在加数字，表示从尾部截断。例如：%-4relative 表示，将输出从程序启动到创建日志记录的时间 进行左对齐 且最小宽度为4。 其他子节点上下文名称 &lt;contextName&gt;设置上下文名称 &lt;contextName&gt;：(默认上下文名称为“default”。可以使用设置成其他名字，用于区分不同应用程序的记录)1234&lt;configuration scan="true" scanPeriod="60 second" debug="false"&gt; &lt;contextName&gt;myAppName&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 变量 &lt;property&gt;设置变量 &lt;property&gt;：(用来定义变量值的标签，&lt;property&gt; 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过&lt;property&gt;定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量)12345&lt;configuration scan="true" scanPeriod="60 second" debug="false"&gt; &lt;property name="APP_Name" value="myAppName" /&gt; &lt;contextName&gt;$&#123;APP_Name&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 时间戳字符串 &lt;timestamp&gt;获取时间戳字符串 &lt;timestamp&gt;:(两个属性 key:标识此 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循 Java.txt.SimpleDateFormat 的格式。)例如将解析配置文件的时间作为上下文名称：12345&lt;configuration scan="true" scanPeriod="60 second" debug="false"&gt; &lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/&gt; &lt;contextName&gt;$&#123;bySecond&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 条件化处理配置文件logback 允许在配置文件中定义条件语句，以决定配置的不同行为。需引用：12345&lt;!-- 可用于在xml中写条件语句 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt; &lt;artifactId&gt;janino&lt;/artifactId&gt;&lt;/dependency&gt; 具体语法格式如下：123456789101112131415&lt;!-- if-then form --&gt; &lt;if condition="some conditional expression"&gt; &lt;then&gt; ... &lt;/then&gt; &lt;/if&gt; &lt;!-- if-then-else form --&gt; &lt;if condition="some conditional expression"&gt; &lt;then&gt; ... &lt;/then&gt; &lt;else&gt; ... &lt;/else&gt; &lt;/if&gt; 以下示例为操作系统判断：1234567891011121314151617181920212223242526272829&lt;!-- Windows操作系统 --&gt;&lt;if condition='property("os.name").contains("Windows")'&gt; &lt;then&gt; &lt;property name="LOG_FILE_ROOT" value="D://opt/applog/logbak-logs" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%level][%thread][%logger.java:%line] - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;/then&gt;&lt;/if&gt;&lt;!-- Linux操作系统 --&gt;&lt;if condition='property("os.name").contains("Linux")'&gt; &lt;then&gt; &lt;property name="LOG_FILE_ROOT" value="/opt/applog/logbak-logs" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%level][%thread][%logger.java:%line] - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;/then&gt;&lt;/if&gt; 文件包含可以使用 ≶include&gt; 标签在一个配置文件中包含另外一个配置文件，如下所示:123456&lt;configuration&gt; &lt;include file="src/main/java/cn/cq/deng/includedConfig.xml"/&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="includedConsole" /&gt; &lt;/root&gt;&lt;/configuration&gt; 被包含的文件必须有以下格式:1234567&lt;included&gt; &lt;appender name="includedConsole" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;"%d - %m%n"&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt;&lt;/included&gt; 支持从多种源头包含: 从文件中包含,&lt;include file=&quot;src/main/java/chapters/configuration/includedConfig.xml&quot;/&gt; 从 classpath 中包含,&lt;include resource=&quot;includedConfig.xml&quot;/&gt; 从 URL 中包含, &lt;include url=&quot;http://some.host.com/includedConfig.xml&quot;/&gt; 如果包含不成功，那么 logback 会打印出一条警告信息，如果不希望 logback 抱怨，只需这样做：&lt;include optional=&quot;true&quot; ..../&gt; 完整配置示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!---scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true-scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。- 当scan为true时，此属性生效。默认的时间间隔为1分钟-debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。-- configuration 子节点为 appender、logger、root--&gt;&lt;configuration scan="true" scanPeriod="60 second" debug="false"&gt; &lt;!-- 负责写日志,控制台日志 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 一是把日志信息转换成字节数组,二是把字节数组写入到输出流 --&gt; &lt;encoder&gt; &lt;Pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%5level] [%thread] %logger&#123;0&#125; %msg%n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件日志 --&gt; &lt;appender name="DEBUG" class="ch.qos.logback.core.FileAppender"&gt; &lt;file&gt;debug.log&lt;/file&gt; &lt;!-- append: true,日志被追加到文件结尾; false,清空现存文件;默认是true --&gt; &lt;append&gt;true&lt;/append&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;!-- LevelFilter: 级别过滤器，根据日志级别进行过滤 --&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;Pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%5level] [%thread] %logger&#123;0&#125; %msg%n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="INFO" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;File&gt;info.log&lt;/File&gt; &lt;!-- ThresholdFilter:临界值过滤器，过滤掉 TRACE 和 DEBUG 级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;Pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%5level] [%thread] %logger&#123;0&#125; %msg%n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 每天生成一个日志文件，保存30天的日志文件 - 如果隔一段时间没有输出日志，前面过期的日志不会被删除，只有再重新打印日志的时候，会触发删除过期日志的操作。 --&gt; &lt;fileNamePattern&gt;info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;TimeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/TimeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender &gt; &lt;!--&lt;!– 异常日志输出 –&gt;--&gt; &lt;!--&lt;appender name="EXCEPTION" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;--&gt; &lt;!--&lt;file&gt;exception.log&lt;/file&gt;--&gt; &lt;!--&lt;!– 求值过滤器，评估、鉴别日志是否符合指定条件. 需要额外的两个JAR包，commons-compiler.jar和janino.jar –&gt;--&gt; &lt;!--&lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter"&gt;--&gt; &lt;!--&lt;!– 默认为 ch.qos.logback.classic.boolex.JaninoEventEvaluator –&gt;--&gt; &lt;!--&lt;evaluator&gt;--&gt; &lt;!--&lt;!– 过滤掉所有日志消息中不包含"Exception"字符串的日志 –&gt;--&gt; &lt;!--&lt;expression&gt;return message.contains("Exception");&lt;/expression&gt;--&gt; &lt;!--&lt;/evaluator&gt;--&gt; &lt;!--&lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt;--&gt; &lt;!--&lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt;--&gt; &lt;!--&lt;/filter&gt;--&gt; &lt;!--&lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt;--&gt; &lt;!--&lt;!– 触发节点，按固定文件大小生成，超过5M，生成新的日志文件 –&gt;--&gt; &lt;!--&lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt;--&gt; &lt;!--&lt;/triggeringPolicy&gt;--&gt; &lt;!--&lt;/appender&gt;--&gt; &lt;appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;error.log&lt;/file&gt; &lt;encoder&gt; &lt;Pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%5level] [%thread] %logger&#123;0&#125; %msg%n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。 - 窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。 - 可以指定文件压缩选项 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;fileNamePattern&gt;error.%d&#123;yyyy-MM&#125;(%i).log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- 异步输出 --&gt; &lt;appender name ="ASYNC" class= "ch.qos.logback.classic.AsyncAppender"&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold &gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;512&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref ="ERROR"/&gt; &lt;/appender&gt; &lt;!-- - 1.name：包名或类名，用来指定受此logger约束的某一个包或者具体的某一个类 - 2.未设置打印级别，所以继承他的上级&lt;root&gt;的日志级别“DEBUG” - 3.未设置additivity，默认为true，将此logger的打印信息向上级传递； - 4.未设置appender，此logger本身不打印任何信息，级别为“DEBUG”及大于“DEBUG”的日志信息传递给root， - root接到下级传递的信息，交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台； --&gt; &lt;logger name="ch.qos.logback" /&gt; &lt;!-- - 1.将级别为“INFO”及大于“INFO”的日志信息交给此logger指定的名为“STDOUT”的appender处理，在控制台中打出日志， - 不再向次logger的上级 &lt;logger name="logback"/&gt; 传递打印信息 - 2.level：设置打印级别（TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF），还有一个特殊值INHERITED或者同义词NULL，代表强制执行上级的级别。 - 如果未设置此属性，那么当前logger将会继承上级的级别。 - 3.additivity：为false，表示此logger的打印信息不再向上级传递,如果设置为true，会打印两次 - 4.appender-ref：指定了名字为"STDOUT"的appender。 --&gt; &lt;logger name="com.weizhi.common.LogMain" level="INFO" additivity="false"&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;!--&lt;appender-ref ref="DEBUG"/&gt;--&gt; &lt;!--&lt;appender-ref ref="EXCEPTION"/&gt;--&gt; &lt;!--&lt;appender-ref ref="INFO"/&gt;--&gt; &lt;!--&lt;appender-ref ref="ERROR"/&gt;--&gt; &lt;appender-ref ref="ASYNC"/&gt; &lt;/logger&gt; &lt;!-- - 根logger - level:设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。 - 默认是DEBUG。 -appender-ref:可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个logger --&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;!--&lt;appender-ref ref="DEBUG"/&gt;--&gt; &lt;!--&lt;appender-ref ref="EXCEPTION"/&gt;--&gt; &lt;!--&lt;appender-ref ref="INFO"/&gt;--&gt; &lt;appender-ref ref="ASYNC"/&gt; &lt;/root&gt;&lt;/configuration&gt; 资源获取 jar包，logback官网下载页链接 maven，pom文件配置如下(${logback-core.version}为版本号，如1.1.7)：12345678910111213141516&lt;!-- logbakc.xml jar --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;$&#123;logback-core.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-access&lt;/artifactId&gt; &lt;version&gt;$&#123;logback-access.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;$&#123;logback-classic.version&#125;&lt;/version&gt;&lt;/dependency&gt; 参考资料logback官网从零开始玩转logbacklogback教程logback 配置详解]]></content>
      <categories>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客语法]]></title>
    <url>%2F2018%2F04%2F18%2Fblog_%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Hexo博客框架使用Markdown语法解析文章。本文主要介绍本网站博客的写作语法：markdown标记语言语法，hexo标签以及next主题的内置标签。 Markdown语法Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 代码高亮采用三个反引号包裹代码。如下： 三个反引号(因解析问题，暂时如此写) js 代码 三个反引号 样例：123function()&#123; console.log('hello,code');&#125; 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是：123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样：1![Alt text][id] id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 参考：Markdown 语法说明 (简体中文版) hexo框架标签插件hexo 是一个快速、简洁且高效的博客框架，本网站采用此框架搭建。下面为hexo博客框架的标签插件。 引用块在文章中插入引言，可包含作者、来源、链接以及标题。PS:注意空格123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;引用内容&#123;% endblockquote %&#125; 简单样例：123&#123;% blockquote %&#125;没有提供参数，则只输出普通的 blockquote&#123;% endblockquote %&#125; 没有提供参数，则只输出普通的 blockquote 复杂样例：123&#123;% blockquote 搜索引擎, baidu https://www.baidu.com/ 百度搜索 %&#125;提供参数:作者, 来源 链接 链接名称&#123;% endblockquote %&#125; 提供参数:作者, 来源 链接 链接名称 搜索引擎, baidu百度搜索 代码块在文章中插入代码。码农enjoy~123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 简单样例123&#123;% codeblock %&#125;alert(&apos;Hello World!&apos;);&#123;% endcodeblock %&#125; 1alert(&apos;Hello World!&apos;); 复杂样例：12345&#123;% codeblock alert lang:js http://www.runoob.com/jquery/jquery-tutorial.html jquery.js%&#125;$(document).ready(function()&#123; alert(&apos;Hello jquery!&apos;);&#125;);&#123;% endcodeblock %&#125; jquery学习jquery123$(document).ready(function()&#123; alert('Hello jquery!');&#125;); 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。格式如下： 三个反引号(因解析问题，暂时如此写) [language] [title] [url] [link text] code snippet 三个反引号 没找到比markdown语法中代码高亮更好的写作体验，我还是采用markdown代码语法。 参考：hexo标签插件（Tag Plugins） next主题内置标签文本居中的引用此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。 例如作为文章开篇引用 或者 结束语之前的总结引用。 使用方式(此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式)。 HTML方式：使用这种方式时，给 img 添加属性 class=”blockquote-center” 即可。 标签方式：使用 centerquote 或者 简写 cq。123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; blah blah blah nocoder 突破容器宽度限制的图片当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。 此标签有两种调用方式（详细参看底下示例）。 使用方式(此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式)。 HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。 标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="full-image" 是必须的 --&gt;&lt;img src="/image-url" class="full-image" /&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% fullimage /image-url, alt, title %&#125;&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125; Bootstrap Callout使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger default(不需设置class_name) (md partial supported) primary (md partial supported) success (md partial supported) info (md partial supported) warning (md partial supported) danger (md partial supported) 参考：next主题内置标签]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle服务脚本]]></title>
    <url>%2F2018%2F03%2F21%2Fbat_oracle%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%81%9C%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[安装了oracle数据库后，由于oracle很占系统资源，而安装后此数据库的很多服务都是默认开机启动的，所以正常情况下我们需要关闭服务，需要使用时打开服务。 Oracle服务介绍 Oracle ORCL VSS Writer Service：Oracle卷映射拷贝写入服务，VSS（Volume Shadow Copy Service）能够让存储基础设备（比如磁盘，阵列等）创建高保真的时间点映像，即映射拷贝（shadow copy）。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统能。（非必须启动） OracleDBConsoleorcl：Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager（企业管理器OEM）的时候，需要启动这个服务。（非必须启动） OracleJobSchedulerORCL：Oracle作业调度（定时器）服务，ORCL是Oracle实例标识。（非必须启动） OracleMTSRecoveryService：服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。（非必须启动） OracleOraDb11g_home1ClrAgent：Oracle数据库.NET扩展服务的一部分。 （非必须启动） OracleOraDb11g_home1TNSListener：监听器服务，服务只有在数据库需要远程访问的时候才需要。（非必须启动，下面会有详细详解）。 OracleServiceORCL：数据库服务(数据库实例)，是Oracle核心服务该服务，是数据库启动的基础， 只有该服务启动，Oracle数据库才能正常启动。(必须启动) 解决方案在window下将代码贴入记事本中，保存为 *.bat 文件。 关闭服务12345@echo offnet stop OracleServiceORCLnet stop OracleOraDb11g_home1TNSListenernet stop OracleOraDb11g_home1ClrAgentnet stop OracleMTSRecoveryService 启动服务12345@echo offnet start OracleMTSRecoveryServicenet start OracleOraDb11g_home1ClrAgentnet start OracleOraDb11g_home1TNSListenernet start OracleServiceORCL]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除SVN版本控制目录]]></title>
    <url>%2F2018%2F03%2F21%2Fbat_%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4SVN%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[svn导出的文件包含svn元信息（版本控制目录），若导出后进行测试或者转移git等，手动删除相关信息是很麻烦的事儿。 解决方案在window下将代码贴入记事本中，保存为 *.bat 文件。在要删除svn信息的文件夹（项目）根目录中复制一份，执行脚本。等待出现结束code:completed，然后按任意键结束即可。123456789@echo on@rem 删除SVN版本控制目录@rem for /r . %%a in (.) do @if exist "%%a\.svn" @echo "%%a\.svn"@for /r . %%a in (.) do @if exist "%%a\.svn" rd /s /q "%%a\.svn"@echo completed@pause]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo,欢迎!]]></title>
    <url>%2F2018%2F03%2F20%2Fhexo_welcome%2F</url>
    <content type="text"><![CDATA[历时三个工作日的休闲时间，搭建完成个人博客网站，以下为搭建历程。具体步骤，请自行baidu,google等~那些大神写的详细的很… before申请github 账户，新建项目(项目必须要遵守格式：账户名.github.io 。不造为撒，但我的没有这样采用…网上以及官方教程都这样写，但是没人解释…) 2018-03-19申请域名，可以在 阿里云 申请配置域名解析 2018-03-20下载安装 node.js使用node.js的npm下载 hexo配置hexo环境,github关联 2018-03-21更换博客主题 themes初步调试以及部署 2018-03-22更换博客主题 next主题优化next主题进阶优化next主题个性化教程:打造炫酷网站 环境变量配置因电脑系统更换，导致个人电脑环境配置出错。因为有安装程序，执行命令时失败。出现类是情况添加环境变量即可（安装上述软件时会默认配置环境变量，故以下供系统重装而文件系统未损坏时时可采纳）： node.j 环境变量：path中添加你的nodejs安装路径，例如：D:\Program Files\nodejs\node-v8.9.3-win-x64; node_modules 环境变量：新建NODE_PATH系统变量，变量值为你的node.js的mode_modules路径：例如：D:\Program Files\nodejs\node-v8.9.3-win-x64\node_modules hexo 环境配置：path中添加你的hexo安装路径下的.bin，例如：G:\hexoWorkspace\node_modules\.bin;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化轶事]]></title>
    <url>%2F2018%2F02%2F23%2Fjava_serializable%2F</url>
    <content type="text"><![CDATA[Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后仍可以将字节数组转换回 Java 对象原有的状态。实际上，序列化的思想是“冻结”对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后“解冻”状态，重新获得可用的 Java 对象。这要归功于 ObjectInputStream/ObjectOutputStream 类、完全保真的元数据以及程序员愿意Serializable标识接口标记他们的类，从而“参与”这个过程。 下面为简单的序列化示例： 将对象序列化后，很容易将对象状态写到磁盘，然后重新读出它，如下： 到现在为止，还没有看到什么新鲜的或令人兴奋的事情。但可以以此来探讨 Java 序列化大多数程序员不知道的的事儿。 序列化允许重构序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。 Java Object Serialization 规范可以自动管理的关键任务是： 将新字段添加到类中 将字段从 static 改为非 static 将字段从 transient 改为非 transient 取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient ）或者删除字段需要额外的消息传递。 重构序列化类：序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西：方法名称、字段名称、字段类型、访问修改方法等计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。 为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的对象必须与第一版有相同的序列化版本 hash（存储为private static final serialVersionUID字段）。因此我们需要 serialVersionUID 字段，它是通过对原始（或V1）版本的类运行 JDK serialver 命令计算出的。 序列化并不安全序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。这对于安全性有着不良影响。例如，当通过RMI进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。 幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。模糊化序列化数据（可以自行更改算法，示例仅供参考）： 如果需要查看被模糊化的数据，总是可以查看序列化数据流/文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。 序列化的数据可以被签名和密封上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。 如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。 序列化允许将代理放在流中很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。 如果首要问题是序列化，那么最好指定一个或代理放在流中。为原始类提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。 打包和解包代理：writeReplace和readResolve 方法使类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。 信任，但要验证认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，信任，但要验证。对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。为此，可以实现 ObjectInputValidatio 接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。 参考深入分析Java的序列化与反序列化 Java Serialization（Java 序列化）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven profile多资源分离打包方案]]></title>
    <url>%2F2017%2F11%2F17%2Fmaven_profile%2F</url>
    <content type="text"><![CDATA[一个项目通常要在多个环境部署，如开发环境、测试环境、生产环境。每种环境都有各自的配置参数，比如：数据库连接、远程调用的 ws 地址等等。如果每个环境都需要人工处理这些配置文件，这显然麻烦且易错。而 maven 提供了一种方便的解决这种问题的方案，就是 profile 功能profile 可以让我们定义一系列的配置信息，然后指定其激活条件。这样我们就可以定义多个 profile，然后每个 profile 对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果。profile 定义的位置： 针对于特定项目的 profile 配置我们可以定义在该项目的 pom.xml 中。 针对于特定用户的 profile 配置，我们可以在用户的 settings.xml 文件中定义 profile 。该文件一般在用户家目录下的 “.m2” 目录下。 全局的 profile 配置。全局的 profile 是定义在 Maven 安装目录下的 “conf/settings.xml” 文件中的。 由于本人所在项目配置文件数目较多（43个资源配置文件），且有些部分资源配置文件开发、测试、生产内容一致，有部分则需区分。(单个资源文件分离较为简单，且网上实施方案较多，本次以所在普通web项目转换为Maven项目遇到问题的实际的解决方案为例)。 实施方案配置资源文件目录在根目录下，创建路径 src/main/profiles 目录(也可以取其他名，与pom文件配置中对应)，该目录下创建 dev、pro 目录（还可以添加测试、本地等目录，但要与 pom.xml 中 profile 配置的目录名相同）。将整理好的开发、生产配置资源文件分别放入对应目录中，maven项目原有 src\main\resources 目录下放置通用的配置资源文件。 项目pom文件配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;properties&gt; &lt;!-- 配置资源相对路径--&gt; &lt;profiles.dir&gt;src/main/profiles&lt;/profiles.dir&gt;&lt;/properties&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;!-- 配置资源相对路径下开发目录 --&gt; &lt;profile.dir&gt;$&#123;profiles.dir&#125;/dev&lt;/profile.dir&gt; &lt;profile.xml&gt;$&#123;profiles.dir&#125;/devXml&lt;/profile.xml&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pro&lt;/id&gt; &lt;properties&gt; &lt;!-- 配置资源相对路径下生产目录 --&gt; &lt;profile.dir&gt;$&#123;profiles.dir&#125;/pro&lt;/profile.dir&gt; &lt;profile.xml&gt;$&#123;profiles.dir&#125;/devXml&lt;/profile.xml&gt; &lt;/properties&gt;&lt;/profile&gt;&lt;/profiles&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;!-- 打包时包含resources文件 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;!-- 开启过滤,（对配置资源路径dev\pro等生效） --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;$&#123;profile.dir&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 数据库源配置信息打包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;$&#123;profile.xml&#125;&lt;/directory&gt; &lt;targetPath&gt;WEB-INF&lt;/targetPath&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.md&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包时候跳过测试 --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;build&gt; 打包操作确认以上无误后进行打包操作，打包命令（根据打包类型在命令后跟上配置的profile的id，如下打包生产配置）：mvn clean install -P pro 可在用户或全局 setting.xml 文件中配置：1234&lt;!--在settings.xml中使用activeProfiles来指定需要激活的profile，这种方式激活的profile将所有情况下都处于激活状态 --&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 这样可以在 Eclipse 下直接运行 run as-&gt;maven install 打包成日常测试或开发包。]]></content>
      <categories>
        <category>MAVEN</category>
      </categories>
      <tags>
        <tag>MAVEN</tag>
        <tag>profile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析HTTP]]></title>
    <url>%2F2016%2F12%2F12%2Fhttp_%E5%B8%B8%E7%94%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[作为WEB网站开发人员，理解 HTTP 协议不可少。HTTP(HyperText Transfer Protocol：超文本传输协议)是互联网上应用最为广泛的一种网络协议。 HTTP 之初识篇HTTP 简介 HTTP 是一个基于 TCP/IP 通信协议来传递数据； HTTP 是一个客户端和服务器端请求和应答的标准（ TCP ）； HTTP 是一个属于应用层的面向对象的协议； HTTP 是一个无状态的协议； HTTP 协议通常承载于 TCP 协议之上，有时也承载于 TLS 或 SSL 协议层之上，这个时候，就成了我们常说的 HTTPS HTTP 流程一次 HTTP 操作称为一个事务，基于 HTTP 协议的客户/服务器模式的信息交换过程，它分四个过程：建立连接、发送请求信息、发送响应信息、关闭连接。 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP 的工作开始。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可能的内容。 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由 HTTP 自己完成的，用户只要用鼠标点击，等待信息显示就可以了 HTTP 之请求篇HTTP请求由三部分组成，分别是：请求行、消息报头、请求正文。 请求行请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如:Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法请求方法有多种，各个方法的解释如下： GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 消息报头详见后文。 请求正文一般为请求表单或者其他类容，例如GET请求： HTTP之响应篇在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文。 状态行状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version 表示服务器 HTTP 协议的版本；Status-Code 表示服务器发回的响应状态代码；Reason-Phrase 表示状态代码的文本描述。 状态码状态码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态码、状态描述以及说明： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 消息报头详见后文。 响应正文服务器根据请求给出的实际响应结果，一般被客户端浏览器所读取展示，例如网页： HTTP之报头篇何为消息报头HTTP 消息由客户端到服务器的请求消息和服务器到客户端的响应消息组成。这两种类型的消息由一个开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），一个或者多个消息报头（可选），一个指示报头结束的空行和消息正文（可选）组成。HTTP 消息报头包括普通报头、请求报头、响应报头、实体报头，每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。 通用报头通用报头包含请求和响应消息都支持的报头，通用报头包含 Cache-Control、Connection、Date、Pragma、Transfer-Encoding 等。简单描述两个例子（详细了解请自行搜索）： Cache-Control 报头：指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control 并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括 no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括 public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。 Date 报头：表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。 请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 Host报头：指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机信息，否则系统会以400状态码返回。 Accept报头：用于指定客户端接受哪些类型的信息。例如：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。 User-Agent报头：允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 Referer报头：允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。 Accept-Encoding报头：类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate。如果请求消息中没有设置这个报头，服务器假定客户端对各种内容编码都可以接受。 Accept-Charset报头：用于指定客户端接受的字符集。例如：Accept-Charset:zh-CN,zh.如果在请求消息中没有设置这个报头，缺省是任何字符集都可以接受。 响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 Server报头：包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。 实体报头请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified等。 Content-Type报头：用于指明发送给接收者的实体正文的媒体类型。 Content-Length报头：用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 Last-Modified报头：用于指示资源的最后修改日期和时间]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat下OutOfMemoryError问题解决]]></title>
    <url>%2F2015%2F08%2F09%2Ftomcat_OutOfMemoryError%2F</url>
    <content type="text"><![CDATA[在eclipse运行tomcat服务器，经常遇到反应慢，时不时出现 OutOfMemoryError: PermGen space 问题。简单来说，项目运行耗费内存资源，内存溢出了。 问题原因当 JVM 需要加载一个新类的定义的却发现在 PermGen 没有足够的空间时，”java.lang.OutOfMemoryError: PermGen Space” 错误便发生了。有两个可能原因会导致内存溢出： 已有的内存空间不足以容纳所有的类； 内存泄漏，GC(Garbage Collection) 不会在主程序运行期对 PermGen space 进行清理，所以如果你的项目会加载很多类的话,就很可能出现 PermGen space 错误。 解决方案通过配置Tomcat的配置文件 catalina.bat（在 Tomcat 安装路径下bin目录，Windows下为catalina.bat而Linux下为catalina.sh文件)可以解决这种问题。 在文件中echo Using CATALINA_BASE: &quot;%CATALINA_BASE%&quot;前加入：1set JAVA_OPTS=%JAVA_OPTS%-server -Xms256m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256m 参数的含义 -vmargs -Xms128M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M -vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了 -Xms128m JVM初始分配的堆内存 -Xmx512m JVM最大允许分配的堆内存，按需分配 -XX:PermSize=64M JVM初始分配的非堆内存 -XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配 在重启你的Tomcat服务器之后，这些配置的更改才会有效。 拓展学习下面解释下堆(Heap)和非堆(Non-heap)内存代表的含义。按照官方的说法： “Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。” “在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。 可以看出 JVM 主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 堆内存分配JVM 初始分配的堆内存由-Xms指定，默认是物理内存的1/64；JVM 最大分配的堆内存由 -Xmx 指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM 就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM 会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。说明：如果 -Xmx 不指定或者指定偏小，应用可能会导致 java.lang.OutOfMemory 错误，此错误来自 JVM，不是 Throwable 的，无法用 try…catch 捕捉。 非堆内存分配JVM 使用 -XX:PermSize 设置非堆内存初始值，默认是物理内存的1/64；由 XX:MaxPermSize 设置最大非堆内存的大小，默认是物理内存的1/4。 上面错误信息中的 PermGen space 的全称是 Permanent Generation space ，是指内存的永久保存区域。还没有弄明白 PermGen space 是属于堆内存，还是属于非堆内存。但 XX:MaxPermSize 设置过小会导致 java.lang.OutOfMemoryError: PermGen space 就是内存益出。 JVM内存限制(最大值)JVM内存限制于实际的最大物理内存，所以设置JVM参数导致程序要注意： 参数中 -Xms 的值不能大于 -Xmx ，或者-XX:PermSize的值不能大于-XX:MaxPermSize； -Xmx 的值和 -XX:MaxPermSize 的总和超过了JVM内存的最大限制；比如当前操作系统最大内存限制，或者实际的物理内存等等。（说到实际物理内存这里需要说明一点的是，如果你的内存是1024MB，但实际系统中并没有这么多，因为有一部分被硬件占用了。）]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
